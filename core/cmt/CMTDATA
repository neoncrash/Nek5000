C> \file CMTDATA include file for CMT variables and common blocks
C> \var U(lxyz,5,lelt) contains nodal values of the five conserved unknowns at
C> each of lx1*ly1*lz1 grid points for all elements
      include 'CMTSIZE' ! new for 2019. usr/case-level declarations that
                        ! depend on flux. all for CMTSURFLX for now

! jface contains free-stream-preserving computation of area PRE-DIVIDED by
! the endpoint quadrature weight!!! This ensures surface fluxes and volume
! fluxe functions can be added directly together at face points
      real                 u(lx1,ly1,lz1,toteq,lelt)
     >                    ,jface(lx1,lz1,2*ldim,lelt)
      common /solnconsvar/ u,jface 
 
      logical            iffltr,    outflsub
     $                , ifcntfilt, ifrestart
      common /input10/   iffltr,    outflsub
     $                , ifcntfilt, ifrestart

      real               phig(lx1,ly1,lz1,lelt)
!     real               ja(lx1*ly1*lz1,ldim*ldim,lelv)
! I really want to set lxd=1 and declare a new rx and call it ja
      common /otherpvar/ phig!,ja

      real res1(lx1,ly1,lz1,lelt,toteq)
     $   , res2(lx1,ly1,lz1,lelt,toteq)
     $   , res3(lx1,ly1,lz1,toteq,lelt) 
      common /cmtres/ res1, res2, res3
      
      real              gradu(lx1*ly1*lz1,3,toteq)
      common /cmtgradu/ gradu     

! JH060418 redimensioned these arrays to interchange equation loop.
!          two-point fluxes really really don't need pointwise
!          if-blocks for equation#
!          see eqnsolver_cmt.f
      real convh (lxd*lyd*lzd,3,toteq)
     $   , diffh (lx1*ly1*lz1,3) ! dealias someday?
     $   , totalh(lxd*lyd*lzd,3,toteq)
      common /convectdata/ convh, diffh, totalh

      real               usrf(lx1,ly1,lz1,5)
      common /forcedata/ usrf 

      real c_sub_e,c_max,meshh(lelt),maxdiff,gridh(lx1*ly1*lz1,lelt),
     $     nu_s,epsebdg(lelt),maxres(lelt),se0(lelt)
      common /planned_Additions/ c_sub_e,c_max,meshh,maxdiff,
     $        gridh,nu_s,epsebdg,maxres,se0

c We assume we will be working with one gas. Therefore Rgas need not be 
c full filed. To begin with we assume calorically perfect gas.
c In near future we relax the constraint to thermally perfect gas.
c------------------------------------------------- -------------------
c NOTE --- CVG need not be stored on full field... removed in future.
c       THis because, Temp will be stored fullfield and we expect Cv to
c       have explicit temp dependence. At the begining of the time step
c       a scratch space will be use to iteratively compute Cv and T from 
c       internal energy.
c--------------------------------------------------------------------- 
      real                csound(lx1,ly1,lz1,lelt)
      common /cmtgasprop/ csound

      real            cpgref,cvgref,cvjref,gmaref,rgasref,molmass,
     $   MAref,MBref,CAref,CBref,   ! NTN for mixed model
     $    rhoidref,rho0ref,EN_IDref,EN_Oref,
     $    MWref,CWref,MCref,CCref,
     $    AAref,
     $    BBref,R1ref,R2ref,OMref,
     $    AA,BB,OM,CC,CW,se0const

      common /cmtgasref/cpgref,cvgref,cvjref,gmaref,rgasref,molmass,
     $    MAref,MBref,CAref,CBref,   ! NTN for mixed model
     $    rhoidref,rho0ref,EN_IDref,EN_Oref,
     $    MWref,CWref,MCref,CCref,
     $    AAref,
     $    BBref,R1ref,R2ref,OMref,
     $    AA,BB,OM,CC,CW,se0const

      integer              stage,nstage,iostep2
      logical 		   dumped_stage
      common /tstepstage/ stage,nstage,iostep2,dumped_stage

      real                  tcoef(3,3),time_cmt,time_iotarg
      common /timestepcoef/ tcoef,time_cmt, time_iotarg
      
      real              rho,phi,pres,cv,e_internal
     $                 ,t0in,p0in,asnd,rgas,cp,mu,lambda,molarmass
      common /nekuscmt/ rho,phi,pres,cv,e_internal
     $                 ,t0in,p0in,asnd,rgas,cp,mu,lambda,molarmass
! let kond=udiff
! VTRANS indices
      integer jden,jcp,jcv
      parameter (jden=1) ! better always be 1
      parameter (jen =2) ! internal energy
      parameter (jcp =3) ! rho*cp ! Really only need one of these, not both
      parameter (jcv =4) ! rho*cv ! Really only need one of these, not both
! indices in VDIFF
      integer jmu, jknd, jlam, jnus
      parameter (jmu =1) ! viscosity
      parameter (jknd=2) ! thermal conductivity
      parameter (jlam=3) ! lambda, 2nd viscosity
      parameter (jnus=4) ! nu_s, mass diffusion (GP14 tensor)
! indices for fields in U
      integer irg, irpu, irpv, irpw, iret
      parameter (irg =1)     ! phi_g*rho_g
      parameter (irpu=2)     ! phi_g*rho_g*u
      parameter (irpv=3)     ! phi_g*rho_g*v
      parameter (irpw=4)     ! phi_g*rho_g*w
      parameter (iret=toteq) ! phi_g*rho_g*E

!-----------------------------------------------------------------------
! JUNKYARD
!-----------------------------------------------------------------------
! legacy indices not long for this world

      integer jcvf, jcpf, jmuf, 
     $        jkndf, jlamf, ju1, ju2, ju3, ju4
!      parameter (jcvf=1)     ! rho*cv
!      parameter (jcpf=1)    ! rho*cp
!      parameter (jmuf=1)    ! mu
!      parameter (jkndf=1)   ! K
!      parameter (jlamf=1)   ! lambda
!NEED TO MAKE SURE IF THESE ARE STILL NEEDED

!      parameter (ju1=1)   ! U1
!      parameter (ju2=1)   ! U2
!      parameter (ju3=1)   ! U3
!      parameter (ju4=1)   ! U4
